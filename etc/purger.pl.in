#!@PERL@
# @configure_input@
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
use strict;
use English;
use vars qw($opt_r $opt_t $opt_m);
use Getopt::Std;

getopts('rt:m:');


my $DATAROOT=shift || die "LAPS_DATA_ROOT required";

# This script purges old data files in directories under the 'lapsprd' 
# directory.  More generally, it purges one or more levels below the
# input directory, not in the directory itself. It purges only those files
# having primarily digits in the name. $hist_time is the age in days of the 
# oldest files to keep.
#
# Command line arguments::
#
# -r -m  default maximum number of files to keep in each directory
#
# -t  default maximum time (days) to keep files in each directory
#
# Overrides can be kept in a file called 'purger.dat' that in the LAPS
# context is placed in the $TEMPLATE and/or $LAPS_DATA_ROOT/static directory.
# Each line in this file has three entries 'a b c' where 'a' is the 'lapsprd'
# subdirectory, 'b' is 'min' or 'max' (not sure how that works myself), and
# 'c' is the purge time in days. An example line in the file would be...
#
# lwc min 1.0
#
# If the user wants to purge in a $DATAROOT subdirectory (ie., no
# subdirectories under this) then use "-r" in conjunction with "-t" and
# input $DATAROOT must not have any subdirectories.
# For example, "purger.pl -r -t 0.5 /data/laps/lapsprd/lt1" will only
# purge files in the lt1 subdirectory using -t 0.5 as the input $hist_time.
# Again, this will not work if there are subdirectories under the input $DATAROOT.
#
# Other exceptions can be listed below...
#
my(%clean_dirs, $hist_time, $min_files);

if($opt_r){
    if(defined $opt_t){
       $hist_time = ($opt_t)?$opt_t:1.5;
    }else{
       $hist_time = 0;
       $min_files = ($opt_m)?$opt_m:0;
    }
}else{
    $hist_time = ($opt_t)?$opt_t:1.5;
#
# Don't ever completely empty the directories 
#

    $min_files = ($opt_m)?$opt_m:5;
}
#
# exceptions - overridden if $min_files==0
#
my $vxx_time = 0.08;
my $vrc_time = 0.16;
my(@radars) = qw(01 02 03 04 05 06 07 08 09 10 11 12 13 14 15);
my $radar;
my($dir);

if($min_files>0){
    $clean_dirs{lga} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{lgb} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{ram} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{rsf} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{fua} = (0.5<$hist_time)?0.5:$hist_time;
    $clean_dirs{fsf} = (0.5<$hist_time)?0.5:$hist_time;

    $clean_dirs{lcv} = 2.1;
    $clean_dirs{l1s} = 2.1;
    $clean_dirs{lm2} = 1.5;
    $clean_dirs{lso} = 1.5;
    $clean_dirs{lwc} = 0.5;

    foreach $radar (@radars){
        $dir="v$radar";
        $clean_dirs{$dir} = $vxx_time;
        $dir="rdr/0$radar/raw";
        $clean_dirs{$dir} = $vrc_time;
        $dir="rdr/0$radar/vrc";
        $clean_dirs{$dir} = $vrc_time;
    }

    $clean_dirs{'lvd/goes08'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/goes09'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/goes10'} = (0.5<$hist_time)?0.5:$hist_time;;
    $clean_dirs{'lvd/gmssat'} = (0.5<$hist_time)?0.5:$hist_time;;

    $clean_dirs{dprep} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{lapsprep} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/output'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'model/varfiles'} = (0.25<$hist_time)?0.25:$hist_time;;
    $clean_dirs{'../log'} = 1.5;

    if(open(OVERRIDES,"$DATAROOT/../static/purger.dat")){
      foreach(<OVERRIDES>){
	next if(/^\#/);
	if(/^\s*(\S+)\s+(\S+)\s+(\S+)/){
          my $what =  $1;
	  my $how= lc $2;
	  my $when= $3;
	  if($how eq "min"){
	    $clean_dirs{$what} = $when;
	  }else{
	    $clean_dirs{$what} = ($when<$hist_time)?$when:$hist_time;
	  }
	  print "Setting purge for $what from purger.dat to $clean_dirs{$what}\n";
	}
      }
      close(OVERRIDES);
    }

}


print "Running $0 for data in $DATAROOT default purge time is $hist_time days \n";
print "Leave a minimum of $min_files in each directory\n";



chdir($DATAROOT) || die "could not chdir to $DATAROOT";
my @subdirs = &dodir('.','.');
foreach (@subdirs){
    next if($_ eq '.');
    $_ =~ s/^\.\///;
    $clean_dirs{$_} = $hist_time if(-d $_  && !$clean_dirs{$_});
}

if ($#subdirs == 0){
    $dir = "./";
    $clean_dirs{$dir} = $hist_time;
}

foreach $dir (keys(%clean_dirs)){
    my(@filelist,@listoffiles,$i,$j);
    opendir(DIR,$dir);

#original constructs
#   if($dir eq '../log'){
#       @filelist = grep(/\d\d$/, readdir(DIR));
#   }else{
#       @filelist = grep(/^\d\d/, readdir(DIR));
#   }

# possibly more generic form for gathering filenames to purge (JS 11-5-00). 

    @filelist = grep(/\d\d\d\d/, readdir(DIR));

    closedir(DIR);
    next unless(-d $dir);
    print "Purging in $dir\n";
    next if($#filelist < $min_files);
    $i=$#filelist;
    my($file, $age);
    foreach $file (sort @filelist){
        stat("$dir/$file");
        $age = -M _;
	next if(-d "$dir/$file");
#        print "$file $age\n";

        if($age > $clean_dirs{$dir} && $i >= $min_files){
            $i--;
            print "Removing file $dir/$file $age $clean_dirs{$dir}\n";
            system("rm -f $dir/$file") ;
	}         

    }
}

sub dodir {
    my($dir,$pattern,$nlink) = @_;
    my($dev,$ino,$mode,$subcount);
    my(@dirlist);
    ($dev,$ino,$mode,$nlink) = stat('.') unless $nlink;


    opendir(DIR,'.');
    my(@filenames) = readdir(DIR);
    closedir(DIR);

    if($nlink==2){                  # directory with no subs
	for (@filenames){
	    next if(/^[\.]+$/);
#            print $_,"\n";
            if($_ =~ $pattern){
#		print "$dir/$_\n";
		push(@dirlist,$dir);
		last;
	    }
	}
    }else{
	$subcount = $nlink-2;
        my($found)=0;
	for(@filenames) {
	    next if(/^[\.]+$/);
	    my $name = "$dir/$_";
	    if(($_ =~ $pattern) && $found==0){
#		print $name,"\n";
                $found++;
		push(@dirlist,$dir);
		
	    }
	    next if $subcount == 0;

	    ($dev,$ino,$mode,$nlink) = lstat($_);

	    next unless -d _;
	    
	    chdir $_ || die "Can't cd to $name\n";
	    push(@dirlist,&dodir($name,$pattern,$nlink));
	    chdir '..';
	    --$subcount;
	}
    }
    return(@dirlist);
}






