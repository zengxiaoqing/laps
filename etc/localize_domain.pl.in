#!@PERL@
# @configure_input@
#
# ******** laps_localization.pl.in  ************************
# ******** localize_domain.pl.in    ************************
# Copyright (C) 1998  James P. Edwards
#
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# J. Smart: 6-09-00: Added command line option no_ggm (for no gridgen_model)
#                    Switch must have a value (like 't' or 'y' or '1') such
#                    that it is defined. If no_ggm is defined laps_localization
#                    only updates namelists and cdl files.
#
# J. Smart: 6-25-01: Modified script to be more generic and adaptable to the
#                    WRFSI domain localization; thus, renamed script to
#                    localize_domain.pl.in ... -w switch to distinguish which
#                    localization (laps or wrfsi).
use strict;
use Getopt::Long;
my($INSTALL_ROOT,$DATA_ROOT,$SOURCE_ROOT,$WHICH_TYPE,$quiet,$sattype,$satid,$no_ggm);

my $result = GetOptions("install_root=s" => \$INSTALL_ROOT,
                        "which_type=s" => \$WHICH_TYPE,
			"dataroot=s" => \$DATA_ROOT,
			"srcroot=s"  => \$SOURCE_ROOT,
			"quiet" => \$quiet, 
			"sattype=s" => \$sattype,
			"satid=s" => \$satid,
                        "no_ggm=s" => \$no_ggm,
			"help" => \&help_sub,
			"<>" => \&help_sub);

sub help_sub{
    print "$0 command line options (default values)\n";
    print "   --install_root = Root directory of the installed binaries (@prefix@)\n";
    print "   --dataroot = Root directory of the installed data (@prefix@/data)\n";
    print "   --srcroot  = Root directory of the source code    (@top_srcdir@)\n";
    print "   --which_type = Specifies localization for either LAPS or WRFSI\n";
    print "   --sattype  = cdf, wfo, gvr, or gwc (guessed based on site)\n";
    print "   --satid    = g8 or g10 (guessed based on -100.0W)\n";
    print "   --no_ggm   = if defined then localization does not run gridgen_model\n";
    print "   --quiet    = Do not query user for verification\n";
    print "   --help     = print this message and exit\n";
    exit;
}

umask 002;

my $thisdir = 'pwd';
chomp($thisdir);
$WHICH_TYPE=lc $WHICH_TYPE;

if(! $SOURCE_ROOT){
    if(-d "@top_srcdir@/src/lib/"){
	$SOURCE_ROOT="@top_srcdir@" ;
    }else{
	$SOURCE_ROOT='/dev/null';
    }
}

$DATA_ROOT = "@prefix@/data" unless($DATA_ROOT);
$INSTALL_ROOT="@prefix@" unless($INSTALL_ROOT);

my $namelist;

if( $WHICH_TYPE eq "laps"){

   print "Preparing a LAPS localization \n";
   $ENV{LAPS_DATA_ROOT} = $DATA_ROOT;
   $namelist = "nest7grid.parms";

}elsif( $WHICH_TYPE eq "wrfsi"){
   
   print "Preparing a WRFSI localization \n";
   $ENV{MOAD_DATAROOT}=$DATA_ROOT;
   $namelist = "wrfsi.nl";

}else{

   print "You need to use --which_type to decide\n";
   print "which localization you desire (laps or wrfsi). Terminating\n";
   exit;
}

require "$INSTALL_ROOT/etc/run_sys.pm";
require "$INSTALL_ROOT/etc/laps_tools.pm";

my $FXA_DATA = $ENV{"FXA_DATA"};

if(-d "$SOURCE_ROOT/data"){
    if(-d "$DATA_ROOT"){
	&safe_cp("$SOURCE_ROOT/data","$DATA_ROOT");
    }else{
	unless($quiet){
	    print "Directory $DATA_ROOT not found - create from $SOURCE_ROOT/data? (y or n)\n";
	    my $key = getc;
	    print "$key\n";
	    exit if($key != 'y');
	}
        my $sys ="cp -r $SOURCE_ROOT/data $DATA_ROOT";
        print $sys;
	run_sys::run_sys($sys);
    }
    &update_nl("$SOURCE_ROOT/data","$DATA_ROOT","$WHICH_TYPE");

}else{
    print "SRC_ROOT directory $SOURCE_ROOT/data not found - proceeding assuming all namelists are up to date\n";
}

if(-d $FXA_DATA){
  print "Localizing for WFO $ENV{FXA_INGEST_SITE}\n";
  $satid = &wfo_localization($SOURCE_ROOT,$INSTALL_ROOT,$DATA_ROOT,$FXA_DATA,$satid);
  $sattype = "wfo";
}
#
# first get the info from the appropriate namelist
open(PARMS,"$DATA_ROOT/static/$namelist");
my($xdim,$ydim,$zdim,$varx,$vary,$varz);
if($namelist eq "wrfsi.nl"){
   $varx="xdim";$vary="ydim";$varz="levels";
}else{
   $varx="NX_L_CMN";$vary="NY_L_CMN";$varz="NK_LAPS";
}

while(<PARMS>){

    $xdim = $1 if(/^\s+$varx\s*=\s*(\d+),/i);
    $ydim = $1 if(/^\s+$vary\s*=\s*(\d+),/i);
    $zdim = $1 if(/^\s+$varz\s*=\s*(\d+),/i);
}
close(PARMS);
$zdim = 1 if ($namelist eq "wrfsi.nl");

if($xdim <=0 || $ydim <= 0 || $zdim<=0){
  print "$0: Error Reading grid size from $DATA_ROOT/static/$namelist\n";
  print "nx=$xdim ny=$ydim nz=$zdim\n";
  exit -1;
}

my @plines;
if( $WHICH_TYPE eq "laps"){
    if(-e "$DATA_ROOT/static/pressures.nl"){
       open(PRES,"$DATA_ROOT/static/pressures.nl");
       @plines = <PRES>;
       close (PRES);
       $zdim = $#plines-2;
       &laps_tools::update_nl($DATA_ROOT,"nest7grid.parms","NK_LAPS",$zdim);
    }else{
       print " ********** WARNING ***************\n";
       print "could not find file pressures.nl in $DATA_ROOT/static\n";
       print "check nest7grid.parms to insure nk_laps is properly set\n";
    }
}
#
# Edit the cdl files for xdim and ydim
#
unless(-d "$DATA_ROOT/cdl"){
    if(-d "$SOURCE_ROOT/data/cdl") {
	run_sys::run_sys("cp -r $SOURCE_ROOT/data/cdl $DATA_ROOT/cdl");
    }else{
	die "Could not find or create cdl directory in $DATA_ROOT/cdl";
    }
}
opendir(CDL_DIR,"$DATA_ROOT/cdl");
my @cdl_list = grep /\.cdl$/, readdir CDL_DIR;
closedir CDL_DIR;

foreach(@cdl_list){
# The next line was commented out on 11 Jan 01 to more closely couple LAPS and any
#   model using the files fua.cdl and fsf.cdl  fua.cdl and fsf.cdl will now be
#   edited to match the LAPS x and y dimensions each time laps_localization.pl is run.
#  \/ The following line no longer applies  \/  11 Jan 01
# DO not edit the model output cdl files, the user must currently edit these by hand.
#
#   next if/^f/;
    open(CDL,"$DATA_ROOT/cdl/$_");
    my @cdl = <CDL>;
    close(CDL);

    open(CDL,">$DATA_ROOT/cdl/$_");
    foreach(@cdl){
	if(/^(\s+)x\s*=/){
	    print CDL "$1x = $xdim,\n" ;
	}elsif(/^(\s+)y\s*=/){
	    print CDL "$1y = $ydim,\n" ;
	}elsif(/^(\s+)z\s*=\s*(\d+)/){
	    if($2>5  && $2!=42){
		print CDL "$1z = $zdim,\n" ;
	    }else{
		print CDL $_ ;
	    }
	}else{
	    print CDL $_;
	}
    }
    close(CDL);
}
#
# localize optran coefficients
#
  if($WHICH_TYPE eq "laps"){
     print "Localizing Optran Coefficients based on moisture_switch.nl namelist settings\n";
     run_sys::run_sys("@PERL@ $INSTALL_ROOT/etc/localize_optran.pl $INSTALL_ROOT/bin/ $DATA_ROOT/static");
  }

#
# run gridgen model if necessary
#

if( !defined $no_ggm ){

    run_sys::run_sys("$INSTALL_ROOT/bin/gridgen_model.exe");	
    print "gridgen_model.exe complete - building sfc lookup tables\n";

    if($WHICH_TYPE eq "laps"){run_sys::run_sys("$INSTALL_ROOT/bin/gensfclut.exe");
       print "gensfclut.exe complete \n";
    }

}else{
    print "not running gridgen_model. Only updating namelists and cdl's\n";
}

#
# Clean out any pre-existing radar remapper look-up tables
#

if($WHICH_TYPE eq "laps"){
   if(-d "$DATA_ROOT/static/vxx"){
    print "cleaning out static/vxx directory of any old luts\n";
    run_sys::run_sys("rm -f $DATA_ROOT/static/vxx/*lut*");
   }else{
    print "Creating directory $DATA_ROOT/static/vxx\n";
    run_sys::run_sys("mkdir $DATA_ROOT/static/vxx");
   }
   if(-d "$DATA_ROOT/static/lvd"){
    print "cleaning out static/lvd directory of any old luts\n";
    run_sys::run_sys("rm -f $DATA_ROOT/static/lvd/*.lut");
   }else{
    print "Creating directory $DATA_ROOT/static/lvd\n";
    run_sys::run_sys("mkdir $DATA_ROOT/static/lvd");
   }
   &static_parms_to_cdl("$DATA_ROOT");
}

print "$0 complete\n";


sub update_nl{
    my($srcroot,$dataroot,$type) = @_;
#
# open and compare nest7grid.parms and *.nl in $srcroot/static and $dataroot/static
# Add variables and files found in $srcroot/static but not $dataroot/static 
# Retain the values of variables found in $dataroot/static for variables in both files
#
# First find all of the variable values in $dataroot/static
#

    opendir(TDIR,"$dataroot/static");
    my @nl = grep(/\.nl$/,readdir(TDIR));
    closedir(TDIR);
    push(@nl,"nest7grid.parms") if(lc $type eq "laps");

    my %nl_vals;
    my %comments;
    my $nl_file;

    foreach $nl_file (@nl){
	print "First pass of namelist parser $nl_file\n";
	open(FILE,"$dataroot/static/$nl_file");
	my @template = <FILE>;
	close(FILE);

	my $var='';
	my $mark=0;
	my $line;
	foreach $line (@template){
	    if($line =~ /^\s*\&/){
		$mark=1;
		next;
	    }elsif($line =~ /^\s*\//){
		$mark=2;
		next;
	    }elsif($line =~ /^[!cC]/){
		$comments{$nl_file} .= $line;
		$mark=3;
		next;
	    }elsif($line =~ /^\s*(\S+)\s*=\s*(.*)$/){
		$var = $1;
                $var =~ tr/a-z/A-Z/;
		$nl_vals{$var} = $2;
		next;
	    }elsif($line =~ /^(.*)$/){
		$nl_vals{$var} .= "\n$1";
		next;
	    }
	    if($mark>0){
		$var = '';
		$mark=0;
	    }
	}

        run_sys::run_sys("cp $dataroot/static/$nl_file $dataroot/static/$nl_file.bak");
    }
    
    opendir(TDIR,"$srcroot/static");
    my @nnl = grep(/\.nl$/,readdir(TDIR));
    closedir(TDIR);
    push(@nnl,"nest7grid.parms") if($type eq "laps");
    
    foreach $nl_file (@nnl){
	open(INFILE,"$srcroot/static/$nl_file");
	my @infile = <INFILE>;
	close(INFILE);
	
	print "merging $srcroot/static/$nl_file into $dataroot/static/$nl_file\n";
	open(OUTFILE,">$dataroot/static/$nl_file") or die "Could not open $dataroot/static/$nl_file to write";
        my($var, $val, $line, $eon);

 	my @comments = split("\n",$comments{$nl_file});

	foreach $line (@infile){
            next if($line eq "\n");
#            print ">$line< ".length($line)."\n";
	    if($line =~ /^\s*\//){
		print "End of namelist section found\n";
		$eon = 1;
                print OUTFILE "\/\n";
                next;
	    }
	    
	    if($line =~ /^\s*(\S+)\s*=\s*(.*)$/){
		$var = $1;
                
                $var =~ tr/a-z/A-Z/;
		$val = $2;
		if(exists $nl_vals{$var}){
#                    print "Found $var = $val\n";
		    $val = $nl_vals{$var};
		}
                $val =~ s/\n$//;
		print OUTFILE " $var = $val\n";
		next;
            }elsif($line =~ /^[!cC]/){
		chomp($line);
		my $tmpline = $line;
		$tmpline =~ s/[(\[\]\\\/\(\)\!\$\^)]/\$1/g;
                next if(grep(/$tmpline/,@comments)>0);
		push(@comments,$line);
		next;
#		print OUTFILE $line;		;
            }elsif($line =~ /^\s*&/){
		print OUTFILE $line;
		next;
	    }elsif(($line =~ /^(\s*[^&\/].*)$/) && exists $nl_vals{$var}){
		next;
	    }
	    print OUTFILE $line;

	}
#       print OUTFILE " \/\n";
	foreach(@comments){
	    print OUTFILE "$_\n";
	}
	close(OUTFILE);
    }

}


sub safe_cp{
    my($indir,$outdir) = @_;
    
    opendir(INDIR,$indir);
    my(@files) = grep !/^\.\.?$/,readdir INDIR;
    close(INDIR);
    my $file;   
    foreach $file (@files){
        next if($file =~ /^CVS$/);
	next if($file =~ /^\#/);
	next if($file =~ /~$/);

	if(-d "$indir/$file"){
	    if(-d "$outdir/$file") {
		&safe_cp("$indir/$file","$outdir/$file");
	    }else{
                print "Copying Directory $indir/$file to $outdir/$file\n";
		run_sys::run_sys("cp -r $indir/$file $outdir/$file");
	    }
	    next;
	}
	next if(-e "$outdir/$file");
        print "Copying file $indir/$file to $outdir/$file\n";
	run_sys::run_sys("cp $indir/$file $outdir/$file");
    }	
}

sub wfo_localization{
  my($SOURCE_ROOT,$INSTALL_ROOT,$DATA_ROOT,$FXA_DATA,$satid) = @_;
  my($root) = $ENV{"FXA_LOCALIZATION_ROOT"};
  my($site) = $ENV{"FXA_INGEST_SITE"};
  my($file1) = "$ENV{FXA_HOME}/data/localizationDataSets/$ENV{FXA_LOCAL_SITE}/whichSat.txt";
  my($file2) = "$root/$site/Laps_Center_Point.txt";
  my($goes) = 0;
  my($lat,$lon);  

  open(LOCFILE,$file2) or die "Can't find $file2.";
  my $line = <LOCFILE>;
  chop($line);
  $line =~ s/ +/,/;
  ($lat,$lon) = split(",",$line);

  if($satid eq "g8"){
      $goes = 8;
  }elsif($satid eq "g10"){
      $goes = 10;
  }elsif(-r $file1){
      open(LOCFILE,$file1) or die "Can't find $file1.";
      my $line = <LOCFILE>;
      close(LOCFILE);
      $goes=10 if($line =~ /WEST/i);      
      $goes=8 if($line =~ /EAST/i);      
  }else{
      $goes = $lon>-100 ? 8:10;  # identifies the goes sat to use based on longitude
  }
  #First files:  the namelist files.


  opendir(NL,"$DATA_ROOT/static");
  my(@templates) = grep(/\.nl/,readdir(NL));
  closedir(NL);
  push(@templates,"nest7grid.parms");
  my $template;
  foreach $template (@templates){
      $template = "$DATA_ROOT/static/$template";

      open(TEMPLATE,"$template") or die "$0: Can't find template file in $template";
      my @template = <TEMPLATE>;
      close(TEMPLATE);
      print "Using static template file $template\n";

      my $i;

      for($i=0;$i<=$#template;){
        if ($template[$i] =~ /=/){
            $i++;
            next;
        }
        if ($template[$i] =~ /^\s*\&/){
            $i++;
            next;
        }
        last if ($template[$i] =~ /^\s*\//);
        
        $template[$i-1]=join('',$template[$i-1],$template[$i]);
        splice(@template,$i,1);
      }

# ISAT = 'goes08, metsat, goes10, gmssat, goes12, goes09

      open(OUTFILE,">$template") or die "$0: Can't open $template to write";

      foreach (@template)
      {
          $_ =~ s/\$FXA_DATA/$FXA_DATA/g;
          if(/standard_latitude\s*=/i){
              print OUTFILE " standard_latitude=$lat,\n";
          }elsif(/standard_longitude\s*=/i){
              print OUTFILE " standard_longitude=$lon,\n";
          }elsif(/grid_cen_lat_cmn\s*=/i){
              print OUTFILE " grid_cen_lat_cmn=$lat,\n";
          }elsif(/grid_cen_lon_cmn\s*=/i){
              print OUTFILE " grid_cen_lon_cmn=$lon,\n";
          }elsif(/\sISATS\s*=/i){
              if($goes==8){
                  print OUTFILE " ISATS = 1,0,0,0,0,0\n";
              }else{
                  print OUTFILE " ISATS = 0,0,1,0,0,0\n";
              }

          }elsif(/\sgoes_switch\s*=/i){
              print OUTFILE " goes_switch = $goes,\n";
          }elsif(/\sITYPES\s*=/i){
              if($goes==8){
                  print OUTFILE " ITYPES = 0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n";
              }else{
                  print OUTFILE " ITYPES = 0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n";
              }

          }else{
              print OUTFILE $_;
          }
      }
      close(OUTFILE);
  }

  $goes = "g".$goes;

# setup background.nl based on site location

  my $old_nl;
  my $new_nl;
  my $command;

# Revert to CONUS if file background.nl.CONUS exists (this assumes localization is CONUS)
  if (-s "$DATA_ROOT/static/background.nl.CONUS") {
    $old_nl = "$DATA_ROOT/static/background.nl.CONUS";
    $new_nl = "$DATA_ROOT/static/background.nl";
    $command = "cp $old_nl $new_nl";
    run_sys::run_sys($command);
  }

# OCONUS namelist setup
# Check for Alaska ingest sites AJK, AFG, AFC, ACR (rfc)
# copy background.nl.AK to background.nl

  if (($site eq "AJK") || ($site eq "AFG") ||
      ($site eq "AFC") || ($site eq "ACR")) {
    if (!-s "$DATA_ROOT/static/background.nl.CONUS") {
      # preserve background.nl if it exists as background.nl.CONUS
      $old_nl = "$DATA_ROOT/static/background.nl";
      $new_nl = "$DATA_ROOT/static/background.nl.CONUS";
      $command = "cp $old_nl $new_nl";
      run_sys::run_sys($command);
    }

    $old_nl = "$DATA_ROOT/static/background.nl.AK";
    $new_nl = "$DATA_ROOT/static/background.nl";
    $command = "cp $old_nl $new_nl";
    run_sys::run_sys($command);
  }

}

sub static_parms_to_cdl{

#J Smart 8-13-02: routine reads LAPS static.nest7grid navigation
#attributes (uses ncdump) and puts these into fua/fsf cdl's.

   my ($LAPS_DATA_ROOT) = @_ ;
   umask 002;

#  $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT} if(defined $ENV{LAPS_DATA_ROOT});
#  if(defined $opt_d) {$LAPS_DATA_ROOT = $opt_d;}
   if( ! defined $LAPS_DATA_ROOT) {
       print "LAPS_DATA_ROOT not defined in sub static_parms_to_cdl\n";
#      print "set env var or use -d command line input\n";
       return;}

   if( !-e "$LAPS_DATA_ROOT/static/static.nest7grid"){
       print "No static file in dataroot. Exit\n";
       exit;
   }

#  require "/usr/nfs/common/lapb/parallel/laps/etc/run_sys.pm";
   my $sys;
   open(SAVEOUT,">&STDOUT");
   select(STDOUT); $| = 1;
   my $OUT_FILE = $LAPS_DATA_ROOT."/log/nav.dat";

#find the grid type (ie., polar, lambert, mercator)
   my @nav_stuff = qw(polar lambert mercator);
   foreach (@nav_stuff) {
     $sys="ncdump -v grid_type $LAPS_DATA_ROOT/static/static.nest7grid | grep $_ 1> $OUT_FILE ";
     run_sys::run_sys($sys,1);
     if(-e "$LAPS_DATA_ROOT/log/nav.dat" && -s "$LAPS_DATA_ROOT/log/nav.dat"){ last;}
   }
#reformat the grid_type output in nav.dat
   open(NAV,"$LAPS_DATA_ROOT/log/nav.dat");
   my $nav_stuff = <NAV>;
   close NAV;
   unlink "$LAPS_DATA_ROOT/log/nav.dat";
   $nav_stuff=" grid_type = ".$nav_stuff;
   open(NAV,">$LAPS_DATA_ROOT/log/nav.dat");
   print NAV $nav_stuff;
   close NAV;
   @nav_stuff = qw(Nx Ny La1 Lo1 La2 Lo2 LoV Latin1 Latin2 Dx Dy);
   my $cdfvar;
   foreach (@nav_stuff) {
      $cdfvar = "\"$_ =\"";
#     print "cdfvar = $cdfvar\n";
      $sys="ncdump -v $_ $LAPS_DATA_ROOT/static/static.nest7grid | grep $cdfvar 1>> $OUT_FILE ";
      run_sys::run_sys($sys,1);
   }
   open(NAV,"$LAPS_DATA_ROOT/log/nav.dat");
   @nav_stuff = <NAV>;
   close NAV;
   unlink "$LAPS_DATA_ROOT/log/nav.dat";

#now append new nav info to fua/fsf cdl files
   my @fuafsf = qw(fua fsf);
   my $cdlfile;
   foreach $cdlfile (@fuafsf){
      open(CDL,"$LAPS_DATA_ROOT/cdl/$cdlfile.cdl");
      my @fuafsf = <CDL>;
      close CDL;
      unlink "$LAPS_DATA_ROOT/cdl/$cdlfile.cdl";
      open(CDL,">$LAPS_DATA_ROOT/cdl/$cdlfile.cdl");
      my $i=0;
      my $ii=0;
      my $nav;
      my @newfuafsf;
      foreach (@fuafsf){
         if($i==$#fuafsf){
            $ii=$i;
            foreach $nav (@nav_stuff){
               @newfuafsf[$ii]="       ".$nav;
               $ii++;
            }
            $i=$ii;
         }
         @newfuafsf[$i]=$_;
         $i++;
      }
      print CDL @newfuafsf;
   }

   return;
}
