#!@PERL@
# @configure_input@
# Run the LAPS suite of programs - sched.pl
#
# Copyright (C) 1998  James P. Edwards
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# This script runs LAPS analyses. The default is for realtime operation.
#
# Command line arguments
#
# -a                   Run for archive time, specified by number of seconds since
#                      Jan 1 1970 at 0000 UTC
#
# -A                   Run for input analysis time specified as dd-mmm-yyyy-hhmm
#                      which can also be a substitute input for archive time
#                      Eg., 28-Aug-2002-1200
#
# -d                   Delay in hours (lag time or displaced real-time)
#
# -e                   Extend time in hours (allow for long runs beyond cycle time)
#
# -q  P                Use QSUB_WAIT (with PBS on jet/ijet) where P is the project name
#
# -Q  P                Use QSUB_WAIT (with SGE on jet/ijet) where P is the project name
#
# -M                   Runs just the executables for the Mesowave analysis
#
# -K                   Runs just the executables for the Kalman filter
#
# -n                   Node type to be used with -q (default=comp)
#
# -w                   Option for creating the WFO big file when LAPS is 
#                      running outside of the WFO environment.
#
# -r -m N              where "N" is the (default) maximum number of files 
#                      to be kept in each product directory by the purger
#
# -t                   override default purge time expressed in days
#
# -s                   runs surface (all LSX variables) and 3-D wind analyses only
#
# -l                   Write logs in LAPS_DATA_ROOT/log, even if on AWIPS
#
# -p T                 Advance analyses by T minutes for balanced output at systime + T
#
# -v                   Run verification binaries 

# second to last arg   $LAPSINSTALLROOT, one level above bin directory
#
# last arg             $LAPS_DATA_ROOT, path to data directory
#                      purger (see call to purger.pl)
#
              
use strict;
use English;
use vars qw($opt_d $opt_c $opt_a $opt_r $opt_m $opt_M $opt_K $opt_t $opt_e $opt_q $opt_Q $opt_n $opt_w 
            $opt_s $opt_l $opt_p $opt_v $opt_A);
use Getopt::Std;

umask 002;
getopts('d:c:a:rm:t:e:q:Q:K:M:n:A:wslvp:');

my $initial_time = time();

my $LAPSROOT=shift || die "LAPS root directory required\n";

$ENV{LAPS_DATA_ROOT} = shift ;
$ENV{LAPS_DATA_ROOT} = "$LAPSROOT/data" if ! $ENV{LAPS_DATA_ROOT};
my $LAPS_DATA_ROOT = $ENV{LAPS_DATA_ROOT};

require "$LAPSROOT/etc/laps_tools.pm";
my @c8_project = &laps_tools::get_nl_value("nest7grid.parms","c8_project_common",$LAPS_DATA_ROOT);
my $c8_project = uc @c8_project[0];

#
# List here the laps products to be executed in the order that they should 
# be executed.
#

my @LAPS_EXE;

if(defined $opt_s){ # "surface only"
    @LAPS_EXE = qw(lga.exe 
                  ingest_pro.exe obs_driver.x sfc_qc.exe 
                  ingest_sounding.exe 
                  ingest_cloud_drift.exe ingest_aircraft.exe 
		  wind.exe 
                  ingest_lrs.exe lvd_sat_ingest.exe 
                  laps_sfc.x);

}elsif(defined $opt_K){ # Kalman only
    @LAPS_EXE = qw(obs_driver.x sfc_qc.exe);

}elsif(defined $opt_M){ # Mesowave
    @LAPS_EXE = qw(obs_driver.x sfc_qc.exe mesowave.x);

}elsif($c8_project eq "AIRDROP"){
    @LAPS_EXE = qw(lga.exe
                   wind.exe laps_sfc.x
                   temp.exe cloud.exe
                   lq3driver.x deriv.exe
                   lsm5.exe
                   qbalpe.exe);

}elsif($c8_project eq "RRV"){
    @LAPS_EXE = qw(mosaic_radar.x);

}else{      # Full product set
    @LAPS_EXE = qw(lga.exe 
                  ingest_pro.exe obs_driver.x sfc_qc.exe
                  ingest_sounding.exe 
                  ingest_cloud_drift.exe ingest_aircraft.exe 
		  wind.exe 
                  ingest_lrs.exe lvd_sat_ingest.exe 
                  laps_sfc.x temp.exe 
                  mosaic_radar.x cloud.exe lq3driver.x deriv.exe accum.exe  
		  lsm5.exe qbalpe.exe lapsprep.exe);
}

if(defined $opt_v){
   push(@LAPS_EXE,"gen_verif_prof.exe");
   push(@LAPS_EXE,"gen_verif_raob.exe");
}
my @WHAT_GOT_IN = qw(wind3d sfc temp hum3d cloud);

require "$LAPSROOT/etc/fxa.pm";

my $fxa_sys = 0;
if (! $opt_l ){
  $fxa_sys =  &Get_env'fxa; #'
}
$ENV{PATH}.=":@NETCDF@/bin";

my @cycle_time=&parse_namelist("$LAPS_DATA_ROOT/static/nest7grid.parms",'laps_cycle_time_cmn');
$cycle_time[0]=~/^(\d+),/;
my $cycle_time = ($1>0)?$1:3600;
$cycle_time = $opt_c if($opt_c>0);
my $cycle_time_min = int($cycle_time/60);

my $delay_time = 0;
$delay_time = $opt_d if($opt_d > 0);

my $extend_time=0;
$extend_time = $opt_e if($opt_e >0);

my $archive_time = 0;
$archive_time = $opt_a if($opt_a > 0);

my @MON = qw(JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC);

if(defined $opt_A){
   if(length($opt_A) != 16){
      print "USEAGE: use -A to input time with the following format\n";
      print "dd-mmm-yyyy-hhmm. Eg., 28-Aug-2002-1200 \n";
      exit;
   }
   my $mon=0;
   my ($day, $month, $year, $hoursmin)=split /\-/, $opt_A;
   my $hours   = substr($hoursmin,0,2);
   my $minutes = substr($hoursmin,2,2);
   foreach (@MON){
       if($_ eq (uc $month)){last;}
       $mon++;
   }
   $mon=$mon+1;
   $mon="0".$mon if(length($mon)<2);

   $archive_time = &laps_tools::date_to_i4time($year,$mon,$day,$hours,$minutes,"00");

#  $archive_time = &seconds_since_1970($opt_A,$LAPSROOT,$LAPS_DATA_ROOT);
}

if(defined $opt_p){
   &laps_tools::update_nl($LAPS_DATA_ROOT,"balance.nl","ADV_ANAL_BY_T_MIN",$opt_p);
}

my $node_type = "comp";

#
#  - The second argument is the time delay in hours to 
#  set the systime.dat file, if you're data arrives more than 1 hour 
#  behind it's valid time set this variable to delay the laps cycle.
#
#  - The '1' (last input) tells sub systime to write ctime.dat and systime.dat; otherwise, not. 
#
#  - If archive time is defined and set to i4time70, then yyjjjhhmm corresponds exactly to archive_time
#
my $yyjjjhhmm=&laps_tools::systime($LAPS_DATA_ROOT,$delay_time,$cycle_time,$archive_time,'1');
#
# This sends the stdout to the run log file
#
my $hh = (gmtime)[2];
my $mm = (gmtime)[1];
my $hhmm = 100*$hh+$mm;
$hhmm = "0".$hhmm while(length($hhmm)<4);
my($LAPS_LOG_PATH,$LAPS_LOCK_PATH);
if(($fxa_sys!=0)and(! $opt_l)){
    $LAPS_LOG_PATH = &Set_logdir'fxa; #'
}else{
    $LAPS_LOG_PATH = "$LAPS_DATA_ROOT/log";
}

if( ((defined $opt_A)or(defined $opt_a))and(-e "/tmp/laps_casererun_log")){
    $LAPS_LOCK_PATH="/tmp/laps_casererun_log";
}else{
    $LAPS_LOCK_PATH=$LAPS_LOG_PATH;
}

open(SAVEOUT,">&STDOUT");
open(SAVEERR,">&STDERR");
#unless(open(STDOUT, ">$LAPS_LOG_PATH/sched.log.$hhmm"))
unless(open(STDOUT, ">$LAPS_LOG_PATH/sched.log.$yyjjjhhmm"))
{ 
  print "WARNING: $0 Can't redirect stdout\n";
}
open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

my $lockfile = "$LAPS_LOCK_PATH/\.locklaps\.$$";

my $sched_lockfile = "$LAPS_LOCK_PATH/sched\.lock";
system("touch $sched_lockfile");

system("uname -ns");

my $t=gmtime(); 
my $sys = "$EXECUTABLE_NAME $LAPSROOT/etc/purger.pl ";

if(! defined $opt_A && ! defined $opt_a){
    print $t." Running purger\n";
    $sys .= "-r " if($opt_r);
    $sys .= "-m $opt_m " if($opt_m);
    $sys .= "-t $opt_t " if($opt_t);
    $sys .= " $LAPS_DATA_ROOT/lapsprd";

    system($sys);
}

open(LOG,">>$LAPS_LOG_PATH/runtime.log");
my($nexe);
my($exe);
my($exenext);
my($execount);
my($scriptcount);
my($scriptnext);
my($wgi_script);
my($command);
my($nodes_last);
my($nodes_current);
my($nodes_next);
my($sms_path);

$nodes_last = 0;
$nodes_next = 1;

$execount = 0;
$scriptcount = 0;

$nexe = @LAPS_EXE;
print "Number of executables = $nexe\n";

foreach $exe (@LAPS_EXE){

    my(@locks);
    opendir(LOCKDIR,"$LAPS_LOCK_PATH");
    @locks = grep /^\.locklaps/, readdir(LOCKDIR);
    closedir(LOCKDIR);

    foreach(@locks){
	$_ =~ /^\.locklaps\.(\d+)$/;
	my $jpid = $1;    
	open(LFH,"$LAPS_LOG_PATH/$_");
	my $prevproc = <LFH>;
	close(LFH);
	$prevproc = ~/^(\d+) (.*)$/;
	my $cid = $1;
	$prevproc = $2;
	next unless ($cid>1);	
	print "WARNING Found LOCK file for sched.pl with pid $jpid and child $cid - killing $prevproc\n";
        open(PS,"ps -ef |");
	my @ps = <PS>;
	close(PS);
#
# Kill any children of the child
#
	foreach(@ps){
	    if ($_ =~ /\s+(\d+)\s+$cid\s+/){
		print "Killing process $1\n";
		kill -9,$1;
	    }
	}
#
# Kill the child
#
	kill -9,$cid if($cid>0);
	unlink "$LAPS_LOCK_PATH/$_";
    }


    $t=gmtime(); 
    my $log = $exe;
#   $log =~ s/\..*$/\.log\.$hhmm/;
    $log =~ s/\..*$/\.log\.$yyjjjhhmm/;

    $execount = $execount + 1;

    if( (! $opt_q) && (! $opt_Q) ){ # Normal run of an executable
        if($exe eq "qbalpe.exe"){
            foreach $wgi_script (@WHAT_GOT_IN){
                print $t." Running what-got-in script $wgi_script.pl\n";
                $sys="$EXECUTABLE_NAME $LAPSROOT/etc/$wgi_script.pl $LAPS_LOG_PATH 1> $LAPS_LOG_PATH/$wgi_script.wgi.$yyjjjhhmm 2>&1";
                &forksub($sys,$lockfile);
            }
        }

        if(-x  "$LAPSROOT/bin/$exe"){
            print $t." Running $exe\n";
            my $sys="$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1";
            &forksub($sys,$lockfile);
        }else{
	    print $t."WARNING: $exe not found\n";
        }

    }else{ # -q or -Q option
#       Set up QSUB_WAIT so that each process (one or more executables in each) submits the next qsub_wait process at the end
        $exenext = $execount + 1;

        $sms_path = "/home/schaffer/sms-2.6.0";

        if($exe =~ "wind"){
            $nodes_current = 1; # 4
        }else{
            $nodes_current = 1;
        }

        if($opt_n){
            $node_type = $opt_n;
        }

        if($execount < $nexe){ # Not yet at end of the list
            if($nodes_last != $nodes_current){ # of nodes has changed OR we are starting

                if($execount > 1){ # after start
                    print TFILE "  \n";
                    print TFILE "/PBSHOME/bin/qsub_wait $LAPS_LOG_PATH/run_qsub_$scriptnext.sh 1> $LAPS_LOG_PATH/run_qsub_$scriptnext.log 2>&1\n";
                    print TFILE "  \n";
                    print $t." Closing $LAPS_LOG_PATH/run_qsub_$scriptcount.sh before executable # $execount\n";
                    close(TFILE);
                }

#               Start new qsub_wait script
                $scriptcount = $scriptcount + 1;
                $scriptnext = $scriptcount + 1;

                print $t." Opening $LAPS_LOG_PATH/run_qsub_$scriptcount.sh starting with executable # $execount\n";
                open(TFILE,">$LAPS_LOG_PATH/run_qsub_$scriptcount.sh");
                print TFILE "#!/bin/sh\n";

                if($opt_q){
                    print TFILE "#PBS -lnodes=$nodes_current:$node_type,walltime=$cycle_time_min:00 -A $opt_q\n";
                }elsif($opt_Q){ 
                    print TFILE "#\$ -pe $node_type $nodes_current\n";
                    print TFILE "#\$ -l h_rt=0:$cycle_time_min:00\n";
                    print TFILE "#\$ -A $opt_Q\n";
                    print TFILE "#\$ -S /bin/sh\n";
                    print TFILE "#\$ -cwd\n";
                }

                print TFILE "  \n";
                print TFILE "cd $LAPS_LOG_PATH\n";
                print TFILE "  \n";

                if($node_type eq "rt"){
                    print TFILE "export PBS_SERVER_LIST=/PBSHOME/lib/server.rt\n";
                    if($opt_q){
                        print TFILE "export PBS_MODE=1\n";
                    }
                    print TFILE "  \n";
                }

                if($nodes_current > 1){
                    print TFILE "export GMPIENVVAR=LAPS_DATA_ROOT:LAPS_SRC_ROOT\n";
                    print TFILE "SMS_SERVER_MODE=serverless\n";
                    print TFILE "export SMS_SERVER_MODE\n";
                    print TFILE "$sms_path/bin/sysSrvr $nodes_current &\n";
                }

                print TFILE "export LAPS_DATA_ROOT=$LAPS_DATA_ROOT\n";
                print TFILE "  \n";
#               print TFILE "date >> $LAPS_LOG_PATH/sched.log.$hhmm\n";
#               print TFILE "  \n";
#               print TFILE "echo 'Running (from qsub_wait) $LAPSROOT/bin/$exe' >> $LAPS_LOG_PATH/sched.log.$hhmm\n";
            }

	}

        print " Adding to $LAPS_LOG_PATH/run_qsub_$scriptcount.sh with executable #/nodes $execount $nodes_current $exe\n";
        print TFILE "  \n";

        if($execount == $nexe){ # Add perl commands to run wfo_post & what-got-in scripts into TFILE

            if($opt_w){ # Bigfile option within qsub environment
                print TFILE "@PERL@ $LAPSROOT/etc/wfo_post.pl -w $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1\n";
            }

            foreach $wgi_script (@WHAT_GOT_IN){
                print TFILE "@PERL@ $LAPSROOT/etc/$wgi_script.pl $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/$wgi_script.wgi.$yyjjjhhmm 2>&1\n";
            }
        }

        if($nodes_current > 1){
            print TFILE "$sms_path/bin/smsRun $nodes_current $LAPSROOT/../../builds_sms/laps/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1\n";
        }else{
            print TFILE "$LAPSROOT/bin/$exe 1> $LAPS_LOG_PATH/$log 2>&1\n";
        }
       
        if($execount == $nexe){ # Last on the list

            print TFILE "  \n";
            print TFILE "echo `date` [finished qsub_wait scripts] >> $LAPS_LOG_PATH/runtime.log\n";
            print TFILE "  \n";
            print $t." Closing $LAPS_LOG_PATH/run_qsub_$scriptcount.sh with executable # $execount\n";
            close(TFILE);

            chdir($LAPS_LOG_PATH) || die "could not chdir to $LAPS_LOG_PATH";
            $command = "/PBSHOME/bin/qsub_wait $LAPS_LOG_PATH/run_qsub_1.sh";
            print "Executing $command\n";
            system("$command");

	}

        $nodes_last = $nodes_current;

    } # if $opt_q or $opt_Q

    my $cur_time = time();

# we won't worry about cycle time overrun if archive case
    if(! $opt_A && ! $opt_a)
    {
       if($cur_time-$initial_time>($cycle_time-$cycle_time*0.01)+$extend_time*3600){
          print "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
          print LOG "ERROR: Exceeding LAPS cycle time in $0 exiting after $exe\n";
          last;
       }
    }
}

$t = gmtime;
my $date = `date`;
print "$date\n";

print LOG "$t\n";
unlink "$sched_lockfile";

if($fxa_sys!=0 || ($opt_w && ( ! ($opt_q || $opt_Q) ) ) ){
    print LOG $t." Running wfo postprocessing\n";

    if($opt_w){
        $sys="$EXECUTABLE_NAME $LAPSROOT/etc/wfo_post.pl -w $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1";
    }else{
        $sys="$EXECUTABLE_NAME $LAPSROOT/etc/wfo_post.pl $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1";
    }

#   system("/usr/nfs/bin/perl $LAPSROOT/etc/wfo_post.pl $LAPSROOT $LAPS_DATA_ROOT 1> $LAPS_LOG_PATH/wfo_post.log.$hhmm 2>&1");

    &forksub($sys,$lockfile);

}elsif($opt_w && ($opt_q || $opt_Q) ){

  if (index($LAPS_DATA_ROOT,"usfsfire/f1") != -1) {

    my $filetime;
    my $dummy;
    my $LAPSTIME = "$LAPS_DATA_ROOT/time/systime.dat";
    open(LAPSTIME,$LAPSTIME) or die "Can't open $LAPSTIME";
    ($filetime,$dummy,$dummy,$dummy) = <LAPSTIME>;
    close(LAPSTIME);
    chomp($filetime); 
    $filetime =~ s/ *//;  #fortran write may have added leading spaces
    $filetime= $filetime - 315619200;

    my $ss;
    my $mm;
    my $hh;
    my $dd;
    my $mon;
    my $yy;
    my $filename;
    ($ss,$mm,$hh,$dd,$mon,$yy) = gmtime($filetime);
    $mon++;
    $yy += 1900;
    $filename = sprintf "%4.4d%2.2d%2.2d_%2.2d00", ($yy,$mon,$dd,$hh);

    $sys = "@PERL@ $LAPSROOT/etc/putFile_fire1.pl $LAPSROOT $filename";
    system("$sys");

  }

}

close(LOG);
#unlink "$lockfile";

sub forksub{
    my($sys,$lockfile) = @_;
  FORK: {      
      my $pid;
      if($pid = fork) {
	  # parent process
	  open(LOCK,">$lockfile");
	  print LOCK "$pid $sys\n";
	  close(LOCK);
	
	  waitpid $pid,0;
	  unlink "$lockfile";	  

      }elsif (defined $pid) { 
	  #child here
	  exec($sys);
	  unlink "$lockfile";
	  exit;
      }elsif ($! =~ /No more process/){
	  # EAGAIN, recoverable fork error
	  sleep 5;
	  redo FORK;
      }else{
	  die "Can't fork: $!\n";
      }
  }
}
#
#------------------------------------------------------------------------
#
sub parse_namelist{
    my($namelist,@variables) = @_;
    my(@ans);
    open(NL,$namelist);
    my @nl = <NL>;
    close(NL);
    my $i;
    for($i=0;$i<=$#nl;$i++){
	next if($nl[$i] =~ /^\s*&/);
	next if($nl[$i] =~ /^\s*\//);
	next if($nl[$i] =~ /^[\!c]/i);

	my $j;
	for($j=0;$j<=$#variables;$j++){

#	    print "here $variables[$j] $nl[$i]\n";
            
	    if($nl[$i] =~ /^\s+$variables[$j]\s*=\s*(.*)$/i){
		my $ans = $1;
		$i++;
		while($nl[$i++]=~/^\s*([^=]+)$/){
		    $ans.=$1;
		}
		$i--;
		$ans[$j]=$ans;
	    }
	}	
    }
    return(@ans);
}
